<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue响应式原理解析]]></title>
    <url>%2F2019%2F12%2F22%2FVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Vue响应式前言数据响应式系统是Vue最显著的一个特性，我们通过Vue官方文档回顾一下。 数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。 现在是时候深入一下了！本文针对响应式系统的原理进行一个详细介绍。 响应式是什么我们先来看一个例子 12345678910111213141516&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;color&#125;&#125;&lt;/p&gt; &lt;button @click="changeColor"&gt;change color!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: '#app', data() &#123; color: 'blue' &#125;, methods: &#123; changeColor() &#123; this.color = 'yellow'; &#125; &#125;&#125;) 当我们点击按钮的时候，视图的p标签文本就会从 blue改变成yellow。 Vue要完成这次更新，其实需要做两件事情： 监听数据color的变化。 当数据color更新变化时，自动通知依赖该数据的视图。 换成专业那么一点点点的名词就是利用数据劫持/数据代理去进行依赖收集、发布订阅模式。 我们只需要记住一句话：在getter中收集依赖，在setter中触发依赖 如何追踪侦测数据的变化首先有个问题，如何侦测一个对象的变化？ 目前来说，侦测对象变化有两种方法。大家都知道的！ Object.definePropertyvue 2.x就是使用Object.defineProperty来数据响应式系统的。但是用此方法来来侦测变化会有很多缺陷。例如: Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。 …… 本文也是利用Object.defineProperty来介绍响应式系统。 Proxyvue3就是通过proxy实现响应式系统的。而且在国庆期间已经发布pre-alpha版本。 相比旧的Object.defineProperty, proxy可以代理整个对象，并且提供了多个traps，可以实现诸多功能。此外，Proxy支持代理数组的变化等等 当然proxy也有一个致命的缺点，就是无法通过polyfill模拟，兼容性较差。 依赖收集的重要角色 Dep WatcherDep、Watcher是数据响应式中两个比较重要的角色。 收集依赖的地方 Dep因为在视图模板上可能有多处地方都引用同一个数据，所以要有一个地方去存放数据的依赖，这个地方就是Dep。 Dep主要维护一个依赖的数组，当我们利用render函数生成VNode的时候，会触发数据的getter，然后则会把依赖push到Dep的依赖数组中。 依赖是Watcher！我们可以把Watcher理解成一个中介的角色，数据发生变化时，会触发数据的setter，然后通过遍历Dep中的依赖Watcher，然后Watcher通知额外的操作，额外的操作可能是更新视图、更新computed、更新watch等等…. 原理实现还是那句话：在getter中收集依赖，在setter中触发依赖。 下面我们看看代码: 代码有点长，下面会有步骤来讲解一次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 劫持数据的getter、setter */function defineReactive(data, key, val) &#123; // 1-1：把color数据变成响应式 const dep = new Dep(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get() &#123; // 3. 因为模板编译watcher访问到了color，从而触发get方法，触发了收集依赖的方法 dep.depend(); return val; &#125;, set(newVal) &#123; if (val === newVal) &#123; return; &#125; val = newVal; // 4-1. 假设我们通过 `this.color = 'yellow';`去更改`color`的值，就会触发set方法。 dep.notify(); &#125; &#125;);&#125;/* * dep类，收集依赖，和触发依赖 */class Dep &#123; constructor() &#123; this.subs = []; // 收集依赖的数组 &#125; // 收集依赖 depend() &#123; // 3-1. 通过外部的变量来添加到color的依赖中. if (window.target &amp;&amp; !this.subs.includes(window.target)) &#123; this.subs.push(window.target); &#125; &#125; // 通知依赖更新 notify() &#123; // 4-2. 遍历 this.subs.forEach(watcher =&gt; &#123; watcher.update(); &#125;); &#125;&#125;/** * 数据与外部的中介 */class Watcher &#123; constructor(expr, cb) &#123; this.cb = cb; this.expr = expr; // 2-1. 这里触发了get方法 this.value = this.get(); &#125; get() &#123; // 2-2. 这里把自己(watcher)赋值给了外部其中的一个变量 window.target = this; // 2-3. data[this.expr]触发了color的get const value = data[this.expr]; window.target = undefined; return value; &#125; update() &#123; this.value = this.get(); this.cb(this.value); &#125;&#125; 我们来走一次步骤。现在我们要把文章开头的例子简易的跑一次..括号里面的1-1，2-2是对应代码的执行点。 1. 把数据变成响应式利用defineReactive把color数据变成响应式（1-1），执行过这个方法后，我们调用console.log(this.color)的时候可以触发get方法。同理当我们this.color = &#39;yellow&#39;。 注意：在Object.defineProperty上面初始化一个存放依赖的dep，这里其实是把dep作为数据color的一个私有变量，让get和set的方法可以访问到，也是我们经常说的闭包。 2. 编译模板创建watcher假设我们现在编译模板遇到。Vue就会创建一个Watchter，伪代码如下：123new Watcher('color', () =&gt; &#123; // 当color发生变化的时候，会触发这里的方法。&#125;); 这里高能！！ Watcher的构造函数里面调用了get()方法（2-2），把自己(watcher)赋值给了一个外部变量。 然后再触发get方法（2-3）。 3. get中收集依赖因为模板编译watcher访问到了color，从而触发get方法，触发了收集依赖的方法。 进入到dep.depend方法中（3-1），这里因为在Watcher中把自己存到了外部变量中，所以在dep.depend方法中可以收集到依赖。 现在，依赖就被收集了。 4. 通过setter触发依赖假设我们通过 this.color = &#39;yellow&#39;;去更改color的值，就会触发set方法，执行dep.notify（4-1）。 会遍历依赖数组，从而去触发Watcher的cb方法。 cb就是上面伪代码new Watcher的那个回调函数。 只要回调函数里面运行了操作dom方法，或者触发了diff算法更新dom，都可以把视图进行更新。 总结Vue响应式的灵魂：在getter中收集依赖，在setter中触发依赖。 我们再看看图，回顾一下整个流程。 通过defineReactive，遍历data里面的属性，把数据的getter/setter劫持，用来收集和触发依赖。 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到Dep依赖中。 当数据发生变化时，会触发setter，从而Dep会向依赖（Wachter）发送通知。 Watcher收到通知后，会向外界发送通知，变化通知到外界后可能接触视图更新，也有可能触发用户的某个回调函数等等。 侦测数据变化的类型其实数据监听变化有两种类型，一种是“推”(push)，另一种是“拉”(pull)。 React和Angular中的变化侦测都属于“拉”，就是说在数据发生变化的时候，它不知道哪个数据变了，然后会发送一个信号给框架，框架收到信号后，会进行一个暴力比对来找出那些dom节点需要重新渲染。Angular中使用的是脏检查，在React使用虚拟dom的diff。 vue的数据监听属于“推”。当数据发生变化时，就知道哪个数据发生变化了，从而去更新有此数据依赖的视图。 因此，框架知道的数据更新信息越多，也就可以进行更细粒度的更新。比如，直接通过dom api操作dom。 相对“拉”的力度是最粗的。看到这里，是不是觉得vue的更新效率最快。 我们看看下面的例子1234&lt;template&gt; &lt;div&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;b&#125;&#125;&lt;/div&gt;&lt;/template&gt; 这里我们看出模板只有a、b两个数据依赖，也就是说我们要创建两个闭包dep去存放两个watcher依赖，我们知道闭包的缺点就是内存泄露。如果有1000个数据依赖在模板上，每个数据所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。 所以，从Vue.js2.0开始，它引入了虚拟dom，一个状态所绑定的依赖不再是具体的dom节点，而是一个组件，即一个组件一个Watcher。 这样状态变化后，会通知到组件，组件内部再使用虚拟 dom进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。但并不是引入虚拟dom后，渲染速度变快了。准确的来说，应该是80%的场景下变得更快了，而剩下的20%反而变慢了。 个人觉得，鱼和熊掌不可兼得。“推”是牺牲内存来换更新速度。“拉”则是牺牲更新速度来获取内存。 参考文献：《深入浅出Vue.js》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试攻略]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[面试的一些攻略递归式快速排序12345678910111213141516171819202122232425262728function quickSort(arr, left, right) &#123; if (left &gt;= right) return // 选择最后一个为基准数 var pivot = right var begin = left var end = right // 如果左边大于等于右边，就退出循环 while (left &lt; right) &#123; while (arr[left] &lt;= arr[pivot] &amp;&amp; left &lt; right) left++ while (arr[right] &gt;= arr[pivot] &amp;&amp; left &lt; right) right-- // 如果交叉了 if (left &gt;= right) &#123; // 交换左节点和基准数的位置 [arr[left], arr[pivot]] = [arr[pivot], arr[left]] pivot = left break &#125; // 如果没交叉，则交换两个数的位置 [arr[left], arr[right]] = [arr[right], arr[left]] &#125; // 递归遍历 quickSort(arr, begin, pivot - 1) quickSort(arr, pivot + 1, end)&#125;var arr = [1, 3, 2, 4, 5, 4, 4, 4, 10, 30, 2, 4, 6,22,1]quickSort(arr, 0, arr.length - 1)console.log(arr) 数组去重利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。示例代码如下： 123456function unique(array) &#123; var obj = &#123;&#125;; return array.filter(function(item, index, array)&#123; return obj.hasOwnProperty(item) ? false : (obj[item] = true) &#125;)&#125; 正则去除空格123456// 去掉所有的html标记str.replace(/&lt;\/?[^&gt;]*&gt;/gim, '');// 去掉前后空格str.replace(/(^\s+)|(\s+$)/g, '');// 去除文章中间空格str.replace(/\s/g, ''); 实现斐波那契数列获得第n项的值斐波那契数列指的是这样一个数列 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368，…… 其规律是：第0项是0，第1项是第一个1。这个数列从第3项开始，每一项都等于前两项之和。 12345678910111213function myFibonacci(n) &#123; if (n &lt; 0) &#123; console.log('You Should input a Positive integer!') return &#125; if (n === 0) &#123; return 0 &#125; if (n === 1) &#123; return 1 &#125; if (n &gt; 1) &#123; return myFibonacci(n - 1) + myFibonacci(n - 2) &#125;&#125;console.log(myFibonacci(21)) 还有很多方法 es6的set集合 1const unique = arr =&gt; [...new Set(arr)] 排序后比较前后两个的值，相同的话干掉一个 bind方法的实现简单版本 不能改变new的this指向 12345678910Function.prototype.myBind = function (context) &#123; if (typeof this !== 'function') &#123; return &#125; var self = this var args = Array.prototype.slice.call(arguments, 1) return function () &#123; return self.apply(context, args.concat(Array.prototype.slice.call(arguments))) &#125;&#125; 完整版本 bind的polyfill MDN传送门 1234567891011121314151617181920212223242526272829303132if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 深拷贝浅拷贝浅拷贝 Object.assign 拓展运算符 遍历一次，如下 1234567function simpleClone(target) &#123; var obj = &#123;&#125; for (var i in target) &#123; obj[i] = target[i] &#125; return obj&#125; 深拷贝 JSON.parse(JSON.stringify)，不能复制function,正则,symbol 递归实现，如下 123456789101112131415161718192021222324252627function deepClone(target) &#123; if (!target || !typeof target === 'object') return target const result = Array.isArray(target) ? [] : &#123;&#125; for (const key in target) &#123; if (target.hasOwnProperty(key)) &#123; const element = target[key] // 因为typeof null也是object，所以要判断element if (element &amp;&amp; typeof element === 'object') &#123; result[key] = deepClone(element) &#125; else &#123; result[key] = element &#125; &#125; &#125; return result&#125;const a = &#123; b: [1,3,4], c: &#123; d: 1 &#125;, d: function () &#123; console.log(1) &#125;&#125;const b = deepClone(a)console.log(b)// function无法复制,lodash源码也没找到console.log(a.d === b.d) // true thiseventLoop javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！ macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。 简单来说，就是 宏任务 -&gt; 全部微任务 -&gt; 宏任务队列的一个任务 -&gt; 全部微任务 -&gt; 宏任务 node环境 中 process.nextTick 注册的函数优先级高于 Promise 。 position兼容性px转换webpackvue双向绑定 Object.defineProperty 遍历检测对象的属性 proxy 代理整个对象的属性，可以检测到数组的长度变化前端优化 减少请求 资源合并和压缩 gzip cdn css精灵图 图片压缩 为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。 最小化 JavaScript 和 CSS 的使用阻塞渲染 css文件放顶部 js文件放底部 避免重定向]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx解决跨域]]></title>
    <url>%2F2019%2F01%2F06%2Fnginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[nginx反向代理解决跨域前言现在的项目大部分都变成前后端分离，前后端项目分开开发，尤其是单页面应用，前端代码会开启单独的服务器，若直接在前端项目中访问后端的接口，肯定会遇到因跨域不能访问的问题。 跨域的常见解决方法 jsonp cors 需要服务器设置header Access-Control-Allow-Origin html5 postMessage+iframe nginx反向代理 实现方法我们只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。 比如接口的前缀是 /api/ 我们可以写多一个location，拦截api，去反向代理接口服务器。 1234567location /api/ &#123; # 所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀 # 重写url，把/api/过滤掉 rewrite ^/api/(.*)$ /$1 break; # API Server proxy_pass http://www.apiServer.com; #将真正的请求代理到apiServer,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.apiServer.com/user/1&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>跨域</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx基础]]></title>
    <url>%2F2019%2F01%2F01%2Fnginx%2F</url>
    <content type="text"><![CDATA[nginx “Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。” 基本操作停止nginx nginx -s stop nginx -s quit killall nginx 重启nginx nginx -s reload 停止服务 systemctl stop nginx.service 重启服务 systemctl restart nginx.service 查看端口号 在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用 netstat -tlnp 命令查看端口号的占用情况。 配置文件(nginx.conf) nginx.conf文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。 下面是文件的详细注释 12345678910111213141516171819202122232425#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include ./include/*; #包含的子配置项位置和文件，因为所有的最好不要全写在这里，容易管理。&#125; location配置语法规则：location [=|~|~*|^~] /uri/ { … } = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~ 和 !~*分别为区分大小写不匹配及不区分大小写不匹配 的正则 / 通用匹配，任何请求都会匹配到。 12345678910111213141516171819202122232425location = / &#123; #规则A&#125;location = /login &#123; #规则B&#125;location ^~ /static/ &#123; #规则C&#125;location ~ \.(gif|jpg|png|js|css)$ &#123; #规则D&#125;location ~* \.png$ &#123; #规则E&#125;location !~ \.xhtml$ &#123; #规则F&#125;location !~* \.xhtml$ &#123; #规则G&#125;location / &#123; #规则H&#125; 那么产生的效果如下： 访问根目录/， 比如 http://localhost/ 将匹配规则A 访问 http://localhost/login 将匹配规则B，http://localhost/register 则匹配规则H 访问 http://localhost/static/a.html 将匹配规则C 访问 http://localhost/a.gif, http://localhost/b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 http://localhost/static/c.png 则优先匹配到 规则C 访问 http://localhost/a.PNG 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。 访问 http://localhost/a.xhtml ，不会匹配规则F和规则G，http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。 访问 http://localhost/category/id/1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。 访问权限在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。即deny all之后，allow谁都没用。 1234location / &#123; deny 192.168.1.23; # 禁止访问 allow 192.168.1.23; # 允许访问&#125; 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。 123456server &#123; listen 8001; # 端口 server_name localhost; # 域名 root /usr/share/nginx/html/html8001; # 路径 index index.html;&#125; 基于域名设置虚拟主机12345678server&#123; listen 80; # 端口 server_name www.crcong.cn; # 域名 location / &#123; root /www.crcong.cn; index index.html index.htm; &#125;&#125; 反向代理 proxy_pass 栗子访问 www.crcong.cn 就会代理到 127.0.0.1:3000 1234567server&#123; listen 80; server_name www.crcong.cn; location / &#123; proxy_pass 127.0.0.1:3000; &#125;&#125; 其他代理指令 proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 gzip gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。 简单开启方式123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; # 压缩文本、JavaScript和css .....&#125; 其他指令 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F12%2F30%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas获取元素并获得2d上下文对象123&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;const canvas = document.querySelector(&apos;#canvas&apos;);const ctx = canvas.getContext(&apos;2d&apos;); 一些坑 不能用css去控制canvas大小，不然会使图形拉伸。可以通过&lt;canvas id=&#39;canvas&#39; width=&#39;500&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;。或者js控制。 栅格(grid)和坐标空间如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。 简单的矩形canvas 只支持一种原生的 图形绘制：矩形。所有其他图形都至少需要生成一种路径(path)。 api fillRect(x, y, width, height) 绘制一个填充的矩形 strockRect(x, y, width, height) 绘制一个矩形的边框 clearRect(x, y, widh, height) 清除指定的矩形区域，然后这块区域会变的完全透明 x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点) width, height：指的是绘制的矩形的宽和高 超出范围会隐藏 strokeRect把一像素的边框渲染成两像素 像这个用canvas绘制出一个方形的时候，由于设置的top值和left值是50px，所以canvas会在第50和第51个像素之间从中间开始绘制一像素的线，第50和第51个像素各占0.5像素。 计算机并不能渲染0.5个像素，所以导致第50和第51个像素都被渲染了，渲染的颜色就成了灰色。（白加黑：背景色加线的颜色） 解决办法 既然会因为0.5像素的问题而渲染了两个像素，那么在设置top值和left值时，增加或减少0.5像素就可以解决了。想绘制在第51个像素就设置50.5，想绘制在第50个像素就设置49.5。 另外，值得注意的是，画出来的方形大小只有99*99像素，要除去一边线的宽度。 路径 图形的基本元素是路径。 路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。 一个路径，甚至一个子路径，都是闭合的。 使用路径绘制图形需要一些额外的步骤： 创建路径起始点 调用绘制方法去绘制出路径 把路径封闭 一旦路径生成，通过描边或填充路径区域来渲染图形。 需要用到的api beginPath() 新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径 moveTo(x, y) 把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。 closePath() 闭合路径之后，图形绘制命令又重新指向到上下文中 stroke() 通过线条来绘制图形轮廓 fill() 通过填充路径的内容区域生成实心的图形 简单例子 123456ctx.beginPath(); //新建一条pathctx.moveTo(50, 50); //把画笔移动到指定的坐标ctx.lineTo(200, 50); //绘制一条从当前位置到指定坐标(200, 50)的直线.//闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做ctx.closePath();ctx.stroke(); //绘制路径。 简单三角形例子 123456789ctx.beginPath();ctx.moveTo(10, 10);ctx.lineTo(10, 40);ctx.lineTo(40, 10);ctx.closePath();ctx.stroke();ctx.closePath(); //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个3角形ctx.stroke(); //描边。stroke不会自动closePath()ctx.fill(); //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径 绘制圆弧 有两个api arc(x, y, r, startAngle, endAngle, anticlockwise)(x, y) 为圆心，以 r 为半径，从 startAngle 弧度开始到 endAngle 弧度结束。anticlosewise 是布尔值，true表示逆时针，false表示顺时针。(默认是顺时针) 注意：这里的度数都是弧度。0弧度是指的x轴正方形 radians = (Math.PI / 180) * degrees; //角度转换成弧度 arcTo(x1, y1, x2, y2, radius)arcTo方法的说明： 这个方法可以这样理解。绘制的弧形是由两条切线所决定。 第 1 条切线：起始点和控制点1决定的直线。 第 2 条切线：控制点1 和控制点2决定的直线。 其实绘制的圆弧就是与这两条直线相切的圆弧。 123456ctx.beginPath();ctx.moveTo(50, 50);//参数1、2：控制点1坐标 参数3、4：控制点2坐标 参数4：圆弧半径ctx.arcTo(200, 50, 200, 200, 100);ctx.lineTo(200, 200)ctx.stroke(); 绘制贝塞尔曲线quadraticCurveTo(cp1x, cp1y, x, y) 说明： 参数1和2：控制点坐标 参数3和4：结束点坐标 添加样式和颜色 如果想要给图形上色，有两个重要的属性可以做到。 fillStyle = color 设置图形的填充颜色 strokeStyle = color 设置图形轮廓的颜色 color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。 默认情况下，线条和填充颜色都是黑色。 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。 Transparency(透明度)globalAlpha = transparencyValue 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。 globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更加好一些。 line style 一些api lineWidth = value 线宽。只能是正值。默认是1.0。 起始点和终点的连线为中心，上下各占线宽的一半。 lineCap = type 线条末端样式。 共有3个值： butt：线段末端以方形结束 round：线段末端以圆形结束 square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。 lineJoin = type 共有3个值round, bevel 和 miter： round 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。 bevel 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。 miter (默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。 绘制虚线用 setLineDash 方法和 lineDashOffset属性来制定虚线样式. setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量 12ctx.setLineDash([20, 5]); // [实线长度, 间隙长度]ctx.lineDashOffset = -0; 绘制文本 两种api fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 123ctx.font = &quot;100px sans-serif&quot;ctx.fillText(&quot;天若有情&quot;, 10, 100);ctx.strokeText(&quot;天若有情&quot;, 10, 200); 给文本添加样式 font = value 当前我们用来绘制文本的样式。这个字符串使用和 CSS font属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 绘制图片 js重零创建图片 js创建文本 12const img = new Image(); // 创建一个&lt;img&gt;元素img.src = &apos;myImage.png&apos;; // 设置图片源地址 然后再绘制到canva 12//参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标ctx.drawImage(img,0,0); 注意： 考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再drawImage。 12345const img = new Image(); // 创建img元素img.onload = function()&#123; ctx.drawImage(img, 0, 0)&#125;img.src = 'myImage.png'; // 设置图片源地址 绘制 img 标签元素中的图片 12var img = document.querySelector("img");ctx.drawImage(img, 0, 0); 缩放图片 drawImage() 也可以再添加两个参数： drawImage(image, x, y, width, height) 这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。 12// 参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标 参数4、5画入时应该缩放的大小。ctx.drawImage(img, 0, 0, 400, 200); 切片 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。 其他8个参数： 前4个是定义图像源的切片位置和大小， 后4个则是定义切片的目标显示位置和大小。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Bus的实现]]></title>
    <url>%2F2018%2F06%2F15%2FeventBus%2F</url>
    <content type="text"><![CDATA[Event Bus的实现 前言Event Bus 使用的范围也很广泛。 react vue 非父子组件就经常用Event Bus进行通信。 Node.js 中的很多模块都依赖Event。 实现思路 Event Bus是 发布订阅模式 的典型应用。 这里实现使用 ES6 语法。 使用方法： 12345678910// 注册一个Event Busconst emitter = new EventEmeitter()// 增加监听事件emitter.on(&apos;test&apos;, a =&gt; &#123; console.log(`on: $&#123;a&#125;`)&#125;)// 触发事件emitter.emit(&apos;test&apos;, &apos;a=10&apos;) 准备工作 创建一个 EventEmeitter 类。 参数 maxListeners 是 监听者 最多能简单多少个事件。 _events 则是 存储事件 的数据结构。 1234constructor(maxListeners) &#123; this._events = new Map() this._maxListeners = (maxListeners &amp;&amp; maxListeners &gt; 0) ? maxListeners : 10&#125; 1. 存储事件 emitter.on(type, fn) 增加监听事件的时候，必需要储存 type 对应的事件。 type对应的 事件(fn) 可能是有多个的。 所以应该使用key: value的方式去存储。第一时间可能想到的是 对象Object。这里使用ES6新增的 Map 作为存储结构。Map用法传送门 那么 Map 的 key 就是 type，value 则是 数组，数组里面存的是需要触发的 函数 。 123456789on(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList) &#123; if (typeFnList.length &gt;= this._maxListeners) return typeFnList.push(fn) &#125; else &#123; this._events.set(type, [fn]) &#125;&#125; 2. 触发事件 emitter.emit(type, ...args) 现在上面所述的 Map 中找出 type 所对应的 函数的数组 。 再遍历数组，执行数组里面所有的函数。 触发监听函数我们可以用 apply 与 call 两种方法，在少数参数时call的性能更好,多个参数时apply性能更好，当年Node的Event模块就在三个参数以下用call否则用 apply。 1234emit(type, ...args) &#123; const typeFnList = this._events.get(type) typeFnList &amp;&amp; typeFnList.forEach(fn =&gt; fn.apply(this, args))&#125; 3. 移除事件 emitter.remove(type, fn)匿名函数不能移除，因为找不到对应的内存。 找出 type 对应的数组。 查到出对应内存的fn，并从数组删除。 123456remove(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList &amp;&amp; typeFnList.includes(fn)) &#123; typeFnList.splice(typeFnList.findIndex(e =&gt; e === fn), 1) &#125;&#125; 总结对Event Bus的原理更加了解。 完整的demo在这]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
</search>
