<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx解决跨域]]></title>
    <url>%2F2019%2F01%2F06%2Fnginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[nginx反向代理解决跨域前言现在的项目大部分都变成前后端分离，前后端项目分开开发，尤其是单页面应用，前端代码会开启单独的服务器，若直接在前端项目中访问后端的接口，肯定会遇到因跨域不能访问的问题。 跨域的常见解决方法 jsonp cors 需要服务器设置header Access-Control-Allow-Origin html5 postMessage+iframe nginx反向代理 实现方法我们只需要配置nginx，在一个服务器上配置多个前缀来转发http/https请求到多个真实的服务器即可。这样，这个服务器上所有url都是相同的域名、协议和端口。 比如接口的前缀是 /api/ 我们可以写多一个location，拦截api，去反向代理接口服务器。 1234567location /api/ &#123; # 所有对后端的请求加一个api前缀方便区分，真正访问的时候移除这个前缀 # 重写url，把/api/过滤掉 rewrite ^/api/(.*)$ /$1 break; # API Server proxy_pass http://www.apiServer.com; #将真正的请求代理到apiServer,即真实的服务器地址，ajax的url为/api/user/1的请求将会访问http://www.apiServer.com/user/1&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx基础]]></title>
    <url>%2F2019%2F01%2F01%2Fnginx%2F</url>
    <content type="text"><![CDATA[nginx “Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。” 基本操作停止nginx nginx -s stop nginx -s quit killall nginx 重启nginx nginx -s reload 停止服务 systemctl stop nginx.service 重启服务 systemctl restart nginx.service 查看端口号 在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用 netstat -tlnp 命令查看端口号的占用情况。 配置文件(nginx.conf) nginx.conf文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。 下面是文件的详细注释 12345678910111213141516171819202122232425#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include ./include/*; #包含的子配置项位置和文件，因为所有的最好不要全写在这里，容易管理。&#125; location配置语法规则：location [=|~|~*|^~] /uri/ { … } = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~ 和 !~*分别为区分大小写不匹配及不区分大小写不匹配 的正则 / 通用匹配，任何请求都会匹配到。 12345678910111213141516171819202122232425location = / &#123; #规则A&#125;location = /login &#123; #规则B&#125;location ^~ /static/ &#123; #规则C&#125;location ~ \.(gif|jpg|png|js|css)$ &#123; #规则D&#125;location ~* \.png$ &#123; #规则E&#125;location !~ \.xhtml$ &#123; #规则F&#125;location !~* \.xhtml$ &#123; #规则G&#125;location / &#123; #规则H&#125; 那么产生的效果如下： 访问根目录/， 比如 http://localhost/ 将匹配规则A 访问 http://localhost/login 将匹配规则B，http://localhost/register 则匹配规则H 访问 http://localhost/static/a.html 将匹配规则C 访问 http://localhost/a.gif, http://localhost/b.jpg 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 http://localhost/static/c.png 则优先匹配到 规则C 访问 http://localhost/a.PNG 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。 访问 http://localhost/a.xhtml ，不会匹配规则F和规则G，http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。 访问 http://localhost/category/id/1111 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。 访问权限在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。即deny all之后，allow谁都没用。 1234location / &#123; deny 192.168.1.23; # 禁止访问 allow 192.168.1.23; # 允许访问&#125; 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。 123456server &#123; listen 8001; # 端口 server_name localhost; # 域名 root /usr/share/nginx/html/html8001; # 路径 index index.html;&#125; 基于域名设置虚拟主机12345678server&#123; listen 80; # 端口 server_name www.crcong.cn; # 域名 location / &#123; root /www.crcong.cn; index index.html index.htm; &#125;&#125; 反向代理 proxy_pass 栗子访问 www.crcong.cn 就会代理到 127.0.0.1:3000 1234567server&#123; listen 80; server_name www.crcong.cn; location / &#123; proxy_pass 127.0.0.1:3000; &#125;&#125; 其他代理指令 proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 gzip gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。 简单开启方式123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; # 压缩文本、JavaScript和css .....&#125; 其他指令 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F12%2F30%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas获取元素并获得2d上下文对象123&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;const canvas = document.querySelector(&apos;#canvas&apos;);const ctx = canvas.getContext(&apos;2d&apos;); 一些坑 不能用css去控制canvas大小，不然会使图形拉伸。可以通过&lt;canvas id=&#39;canvas&#39; width=&#39;500&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;。或者js控制。 栅格(grid)和坐标空间如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。 简单的矩形canvas 只支持一种原生的 图形绘制：矩形。所有其他图形都至少需要生成一种路径(path)。 api fillRect(x, y, width, height) 绘制一个填充的矩形 strockRect(x, y, width, height) 绘制一个矩形的边框 clearRect(x, y, widh, height) 清除指定的矩形区域，然后这块区域会变的完全透明 x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点) width, height：指的是绘制的矩形的宽和高 超出范围会隐藏 strokeRect把一像素的边框渲染成两像素 像这个用canvas绘制出一个方形的时候，由于设置的top值和left值是50px，所以canvas会在第50和第51个像素之间从中间开始绘制一像素的线，第50和第51个像素各占0.5像素。 计算机并不能渲染0.5个像素，所以导致第50和第51个像素都被渲染了，渲染的颜色就成了灰色。（白加黑：背景色加线的颜色） 解决办法 既然会因为0.5像素的问题而渲染了两个像素，那么在设置top值和left值时，增加或减少0.5像素就可以解决了。想绘制在第51个像素就设置50.5，想绘制在第50个像素就设置49.5。 另外，值得注意的是，画出来的方形大小只有99*99像素，要除去一边线的宽度。 路径 图形的基本元素是路径。 路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。 一个路径，甚至一个子路径，都是闭合的。 使用路径绘制图形需要一些额外的步骤： 创建路径起始点 调用绘制方法去绘制出路径 把路径封闭 一旦路径生成，通过描边或填充路径区域来渲染图形。 需要用到的api beginPath() 新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径 moveTo(x, y) 把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。 closePath() 闭合路径之后，图形绘制命令又重新指向到上下文中 stroke() 通过线条来绘制图形轮廓 fill() 通过填充路径的内容区域生成实心的图形 简单例子 123456ctx.beginPath(); //新建一条pathctx.moveTo(50, 50); //把画笔移动到指定的坐标ctx.lineTo(200, 50); //绘制一条从当前位置到指定坐标(200, 50)的直线.//闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做ctx.closePath();ctx.stroke(); //绘制路径。 简单三角形例子 123456789ctx.beginPath();ctx.moveTo(10, 10);ctx.lineTo(10, 40);ctx.lineTo(40, 10);ctx.closePath();ctx.stroke();ctx.closePath(); //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个3角形ctx.stroke(); //描边。stroke不会自动closePath()ctx.fill(); //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径 绘制圆弧 有两个api arc(x, y, r, startAngle, endAngle, anticlockwise)(x, y) 为圆心，以 r 为半径，从 startAngle 弧度开始到 endAngle 弧度结束。anticlosewise 是布尔值，true表示逆时针，false表示顺时针。(默认是顺时针) 注意：这里的度数都是弧度。0弧度是指的x轴正方形 radians = (Math.PI / 180) * degrees; //角度转换成弧度 arcTo(x1, y1, x2, y2, radius)arcTo方法的说明： 这个方法可以这样理解。绘制的弧形是由两条切线所决定。 第 1 条切线：起始点和控制点1决定的直线。 第 2 条切线：控制点1 和控制点2决定的直线。 其实绘制的圆弧就是与这两条直线相切的圆弧。 123456ctx.beginPath();ctx.moveTo(50, 50);//参数1、2：控制点1坐标 参数3、4：控制点2坐标 参数4：圆弧半径ctx.arcTo(200, 50, 200, 200, 100);ctx.lineTo(200, 200)ctx.stroke(); 绘制贝塞尔曲线quadraticCurveTo(cp1x, cp1y, x, y) 说明： 参数1和2：控制点坐标 参数3和4：结束点坐标 添加样式和颜色 如果想要给图形上色，有两个重要的属性可以做到。 fillStyle = color 设置图形的填充颜色 strokeStyle = color 设置图形轮廓的颜色 color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。 默认情况下，线条和填充颜色都是黑色。 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。 Transparency(透明度)globalAlpha = transparencyValue 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。 globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更加好一些。 line style 一些api lineWidth = value 线宽。只能是正值。默认是1.0。 起始点和终点的连线为中心，上下各占线宽的一半。 lineCap = type 线条末端样式。 共有3个值： butt：线段末端以方形结束 round：线段末端以圆形结束 square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。 lineJoin = type 共有3个值round, bevel 和 miter： round 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。 bevel 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。 miter (默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。 绘制虚线用 setLineDash 方法和 lineDashOffset属性来制定虚线样式. setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量 12ctx.setLineDash([20, 5]); // [实线长度, 间隙长度]ctx.lineDashOffset = -0; 绘制文本 两种api fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 123ctx.font = &quot;100px sans-serif&quot;ctx.fillText(&quot;天若有情&quot;, 10, 100);ctx.strokeText(&quot;天若有情&quot;, 10, 200); 给文本添加样式 font = value 当前我们用来绘制文本的样式。这个字符串使用和 CSS font属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 绘制图片 js重零创建图片 js创建文本 12const img = new Image(); // 创建一个&lt;img&gt;元素img.src = &apos;myImage.png&apos;; // 设置图片源地址 然后再绘制到canva 12//参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标ctx.drawImage(img,0,0); 注意： 考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再drawImage。 12345const img = new Image(); // 创建img元素img.onload = function()&#123; ctx.drawImage(img, 0, 0)&#125;img.src = 'myImage.png'; // 设置图片源地址 绘制 img 标签元素中的图片 12var img = document.querySelector("img");ctx.drawImage(img, 0, 0); 缩放图片 drawImage() 也可以再添加两个参数： drawImage(image, x, y, width, height) 这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。 12// 参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标 参数4、5画入时应该缩放的大小。ctx.drawImage(img, 0, 0, 400, 200); 切片 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。 其他8个参数： 前4个是定义图像源的切片位置和大小， 后4个则是定义切片的目标显示位置和大小。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Bus的实现]]></title>
    <url>%2F2018%2F06%2F15%2FeventBus%2F</url>
    <content type="text"><![CDATA[Event Bus的实现 前言Event Bus 使用的范围也很广泛。 react vue 非父子组件就经常用Event Bus进行通信。 Node.js 中的很多模块都依赖Event。 实现思路 Event Bus是 发布订阅模式 的典型应用。 这里实现使用 ES6 语法。 使用方法： 12345678910// 注册一个Event Busconst emitter = new EventEmeitter()// 增加监听事件emitter.on(&apos;test&apos;, a =&gt; &#123; console.log(`on: $&#123;a&#125;`)&#125;)// 触发事件emitter.emit(&apos;test&apos;, &apos;a=10&apos;) 准备工作 创建一个 EventEmeitter 类。 参数 maxListeners 是 监听者 最多能简单多少个事件。 _events 则是 存储事件 的数据结构。 1234constructor(maxListeners) &#123; this._events = new Map() this._maxListeners = (maxListeners &amp;&amp; maxListeners &gt; 0) ? maxListeners : 10&#125; 1. 存储事件 emitter.on(type, fn) 增加监听事件的时候，必需要储存 type 对应的事件。 type对应的 事件(fn) 可能是有多个的。 所以应该使用key: value的方式去存储。第一时间可能想到的是 对象Object。这里使用ES6新增的 Map 作为存储结构。Map用法传送门 那么 Map 的 key 就是 type，value 则是 数组，数组里面存的是需要触发的 函数 。 123456789on(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList) &#123; if (typeFnList.length &gt;= this._maxListeners) return typeFnList.push(fn) &#125; else &#123; this._events.set(type, [fn]) &#125;&#125; 2. 触发事件 emitter.emit(type, ...args) 现在上面所述的 Map 中找出 type 所对应的 函数的数组 。 再遍历数组，执行数组里面所有的函数。 触发监听函数我们可以用 apply 与 call 两种方法，在少数参数时call的性能更好,多个参数时apply性能更好，当年Node的Event模块就在三个参数以下用call否则用 apply。 1234emit(type, ...args) &#123; const typeFnList = this._events.get(type) typeFnList &amp;&amp; typeFnList.forEach(fn =&gt; fn.apply(this, args))&#125; 3. 移除事件 emitter.remove(type, fn)匿名函数不能移除，因为找不到对应的内存。 找出 type 对应的数组。 查到出对应内存的fn，并从数组删除。 123456remove(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList &amp;&amp; typeFnList.includes(fn)) &#123; typeFnList.splice(typeFnList.findIndex(e =&gt; e === fn), 1) &#125;&#125; 总结对Event Bus的原理更加了解。 完整的demo在这]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
</search>
