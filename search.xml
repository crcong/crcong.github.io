<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F12%2F30%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas获取元素并获得2d上下文对象123&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;const canvas = document.querySelector(&apos;#canvas&apos;);const ctx = canvas.getContext(&apos;2d&apos;); 一些坑 不能用css去控制canvas大小，不然会使图形拉伸。可以通过&lt;canvas id=&#39;canvas&#39; width=&#39;500&#39; height=&#39;400&#39;&gt;&lt;/canvas&gt;。或者js控制。 栅格(grid)和坐标空间如下图所示，canvas元素默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。 简单的矩形 只支持一种原生的 图形绘制：矩形。所有其他图形都至少需要生成一种路径(path)。 api y, width, height)``` 绘制一个填充的矩形12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- ```strockRect(x, y, width, height)``` 绘制一个矩形的边框- ```clearRect(x, y, widh, height)``` 清除指定的矩形区域，然后这块区域会变的完全透明x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)width, height：指的是绘制的矩形的宽和高超出范围会隐藏&gt; strokeRect把一像素的边框渲染成两像素- 像这个用canvas绘制出一个方形的时候，由于设置的top值和left值是50px，所以canvas会在第50和第51个像素之间从中间开始绘制一像素的线，第50和第51个像素各占0.5像素。- 计算机并不能渲染0.5个像素，所以导致第50和第51个像素都被渲染了，渲染的颜色就成了灰色。（白加黑：背景色加线的颜色）&gt; 解决办法既然会因为0.5像素的问题而渲染了两个像素，那么在设置top值和left值时，增加或减少0.5像素就可以解决了。想绘制在第51个像素就设置50.5，想绘制在第50个像素就设置49.5。另外，值得注意的是，画出来的方形大小只有99*99像素，要除去一边线的宽度。### 路径- 图形的基本元素是路径。- 路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。- 一个路径，甚至一个子路径，都是闭合的。&gt; 使用路径绘制图形需要一些额外的步骤：1. 创建路径起始点2. 调用绘制方法去绘制出路径3. 把路径封闭4. 一旦路径生成，通过描边或填充路径区域来渲染图形。&gt; 需要用到的api```beginPath()``` 新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径```moveTo(x, y)``` 把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。```closePath()``` 闭合路径之后，图形绘制命令又重新指向到上下文中```stroke()``` 通过线条来绘制图形轮廓```fill()``` 通过填充路径的内容区域生成实心的图形&gt; 简单例子 ctx.beginPath(); //新建一条pathctx.moveTo(50, 50); //把画笔移动到指定的坐标ctx.lineTo(200, 50); //绘制一条从当前位置到指定坐标(200, 50)的直线.//闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做ctx.closePath();ctx.stroke(); //绘制路径。12&gt; 简单三角形例子 ctx.beginPath();ctx.moveTo(10, 10);ctx.lineTo(10, 40);ctx.lineTo(40, 10);ctx.closePath();ctx.stroke();ctx.closePath(); //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个3角形ctx.stroke(); //描边。stroke不会自动closePath()ctx.fill(); //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径123456### 绘制圆弧&gt; 有两个api##### ```arc(x, y, r, startAngle, endAngle, anticlockwise) (x, y) 为圆心，以 r 为半径，从 startAngle 弧度开始到 endAngle 弧度结束。anticlosewise 是布尔值，true表示逆时针，false表示顺时针。(默认是顺时针) 注意：这里的度数都是弧度。0弧度是指的x轴正方形 12##### ```arcTo(x1, y1, x2, y2, radius) arcTo方法的说明： 这个方法可以这样理解。绘制的弧形是由两条切线所决定。 第 1 条切线：起始点和控制点1决定的直线。 第 2 条切线：控制点1 和控制点2决定的直线。 其实绘制的圆弧就是与这两条直线相切的圆弧。 123456ctx.beginPath();ctx.moveTo(50, 50);//参数1、2：控制点1坐标 参数3、4：控制点2坐标 参数4：圆弧半径ctx.arcTo(200, 50, 200, 200, 100);ctx.lineTo(200, 200)ctx.stroke(); 绘制贝塞尔曲线cp1y, x, y)```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162说明：参数1和2：控制点坐标参数3和4：结束点坐标### 添加样式和颜色&gt; 如果想要给图形上色，有两个重要的属性可以做到。`fillStyle = color` 设置图形的填充颜色`strokeStyle = color` 设置图形轮廓的颜色1. `color` 可以是表示 `css` 颜色值的字符串、渐变对象或者图案对象。2. 默认情况下，线条和填充颜色都是黑色。3. 一旦您设置了 `strokeStyle` 或者 `fillStyle` 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 `fillStyle` 或 `strokeStyle` 的值。### Transparency(透明度)`globalAlpha = transparencyValue`这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更加好一些。### line style&gt; 一些api1. `lineWidth = value`线宽。只能是正值。默认是1.0。起始点和终点的连线为中心，**上下各占线宽的一半**。2. `lineCap = type`线条末端样式。共有3个值：- butt：线段末端以方形结束- round：线段末端以圆形结束- square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。3. `lineJoin = type`共有3个值`round`, `bevel` 和 `miter`：- `round` 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。- `bevel` 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。- `miter` (默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。### 绘制虚线用 `setLineDash` 方法和 `lineDashOffset `属性来制定虚线样式. `setLineDash` 方法接受一个数组，来指定线段与间隙的交替；`lineDashOffset`属性设置起始偏移量 ctx.setLineDash([20, 5]); // [实线长度, 间隙长度]ctx.lineDashOffset = -0;1234567891011### 绘制文本&gt; 两种api1. `fillText(text, x, y [, maxWidth])`在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.2. `strokeText(text, x, y [, maxWidth])`在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. ctx.font = “100px sans-serif”ctx.fillText(“天若有情”, 10, 100);ctx.strokeText(“天若有情”, 10, 200);12345678910111213&gt; 给文本添加样式1. `font = value` 当前我们用来绘制文本的样式。这个字符串使用和 CSS font属性相同的语法. 默认的字体是 10px sans-serif。2. `textAlign = value` 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。3. `textBaseline = value` 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。4. `direction = value` 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。### 绘制图片&gt; js重零创建图片js创建文本 const img = new Image(); // 创建一个元素img.src = ‘myImage.png’; // 设置图片源地址12然后再绘制到canva //参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标ctx.drawImage(img,0,0);1234注意：考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再drawImage。 const img = new Image(); // 创建img元素img.onload = function(){ ctx.drawImage(img, 0, 0)}img.src = ‘myImage.png’; // 设置图片源地址12&gt; 绘制 img 标签元素中的图片 var img = document.querySelector(“img”);ctx.drawImage(img, 0, 0);12345678&gt; 缩放图片drawImage() 也可以再添加两个参数：drawImage(image, x, y, width, height)这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。 // 参数1：要绘制的img 参数2、3：绘制的img在canvas中的坐标 参数4、5画入时应该缩放的大小。ctx.drawImage(img, 0, 0, 400, 200);` 切片 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。 其他8个参数： 前4个是定义图像源的切片位置和大小， 后4个则是定义切片的目标显示位置和大小。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Bus的实现]]></title>
    <url>%2F2018%2F06%2F15%2FeventBus%2F</url>
    <content type="text"><![CDATA[Event Bus的实现 前言Event Bus 使用的范围也很广泛。 react vue 非父子组件就经常用Event Bus进行通信。 Node.js 中的很多模块都依赖Event。 实现思路 Event Bus是 发布订阅模式 的典型应用。 这里实现使用 ES6 语法。 使用方法： 12345678910// 注册一个Event Busconst emitter = new EventEmeitter()// 增加监听事件emitter.on(&apos;test&apos;, a =&gt; &#123; console.log(`on: $&#123;a&#125;`)&#125;)// 触发事件emitter.emit(&apos;test&apos;, &apos;a=10&apos;) 准备工作 创建一个 EventEmeitter 类。 参数 maxListeners 是 监听者 最多能简单多少个事件。 _events 则是 存储事件 的数据结构。 1234constructor(maxListeners) &#123; this._events = new Map() this._maxListeners = (maxListeners &amp;&amp; maxListeners &gt; 0) ? maxListeners : 10&#125; 1. 存储事件 emitter.on(type, fn) 增加监听事件的时候，必需要储存 type 对应的事件。 type对应的 事件(fn) 可能是有多个的。 所以应该使用key: value的方式去存储。第一时间可能想到的是 对象Object。这里使用ES6新增的 Map 作为存储结构。Map用法传送门 那么 Map 的 key 就是 type，value 则是 数组，数组里面存的是需要触发的 函数 。 123456789on(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList) &#123; if (typeFnList.length &gt;= this._maxListeners) return typeFnList.push(fn) &#125; else &#123; this._events.set(type, [fn]) &#125;&#125; 2. 触发事件 emitter.emit(type, ...args) 现在上面所述的 Map 中找出 type 所对应的 函数的数组 。 再遍历数组，执行数组里面所有的函数。 触发监听函数我们可以用 apply 与 call 两种方法，在少数参数时call的性能更好,多个参数时apply性能更好，当年Node的Event模块就在三个参数以下用call否则用 apply。 1234emit(type, ...args) &#123; const typeFnList = this._events.get(type) typeFnList &amp;&amp; typeFnList.forEach(fn =&gt; fn.apply(this, args))&#125; 3. 移除事件 emitter.remove(type, fn)匿名函数不能移除，因为找不到对应的内存。 找出 type 对应的数组。 查到出对应内存的fn，并从数组删除。 123456remove(type, fn) &#123; const typeFnList = this._events.get(type) if (typeFnList &amp;&amp; typeFnList.includes(fn)) &#123; typeFnList.splice(typeFnList.findIndex(e =&gt; e === fn), 1) &#125;&#125; 总结对Event Bus的原理更加了解。 完整的demo在这]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原生js</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
</search>
